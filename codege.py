import os
import sys

required_package = {
    'ccsyspath': {'package': 'ccsyspath', 'version': '1.1.0'},
    'clang': {'package': 'libclang', 'version': '9.0.1'},
    'click': {'package': 'click', 'version': '7.1.2'},
}

def install_package(name: str, package: str, version: str) -> bool:
    import importlib.util, subprocess

    spec = importlib.util.find_spec(name)
    if spec is None:
        print(f'{name} not found. Installing {package}=={version}...')
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--user', f'{package}=={version}'])
        except subprocess.CalledProcessError:
            print(f'Failed to install {package}=={version}, please install it manually.')
            sys.exit(1)
        return True
    return False

def bootstrap():
    need_restart = False
    for name, info in required_package.items():
        need_restart = install_package(name, info['package'], info['version']) or need_restart
    if need_restart:
        import subprocess
        ret_code = subprocess.call([sys.executable] + sys.argv)
        sys.exit(ret_code)

bootstrap()


# Actual code starts here

import re
import ccsyspath
import clang.cindex as CX
from typing import List, TextIO, Optional
import click

class FieldInfo:
    def __init__(self, name: str, field_type: str, extras: dict) -> None:
        self.name = name
        self.field_type = field_type
        self.extras = extras
    def __str__(self) -> str:
        return f'{self.name}: {self.field_type}' + (f' {self.extras}' if self.extras else '')
   
class StructInfo:
    def __init__(self, name: str, canonical_name: str, fields: List[FieldInfo]) -> None:
        self.name = name
        self.canonical_name = canonical_name
        self.fields = fields
    def __str__(self) -> str:
        return f'{self.name} ({self.canonical_name})' + '\n' + '\n'.join(map(str, self.fields))

def escape_value(value: str) -> str:
    if value[-1] == '\\':
        value = value[:-1]
    value.replace('"', '\\"')
    return value

def get_struct_fields(cursor: CX.Cursor) -> Optional[StructInfo]:
    def extract_extras(raw_comment: str) -> dict:
        pattern = r"@(?P<k>[a-zA-Z]+)\s+(?P<v>.+)$"
        extras = {}
        matches = re.finditer(pattern, raw_comment, re.MULTILINE)
        for match in matches:
            extras[match.group('k')] = escape_value(match.group('v'))
        return extras

    if cursor.kind != CX.CursorKind.STRUCT_DECL:
        print(f'Error: {cursor.spelling} is not a struct')
        return None
    
    name = cursor.spelling
    canonical_name = cursor.type.get_canonical().spelling
    
    fields = filter(lambda x: x.kind == CX.CursorKind.FIELD_DECL, cursor.get_children())
    infos : List[FieldInfo] = []
    for field in fields:
        name = field.spelling
        field_type = field.type.get_canonical().spelling
        extras = extract_extras(field.raw_comment)
        infos.append(FieldInfo(name, field_type, extras))

    return StructInfo(name, canonical_name, infos)
        
def find_namespace(cursor: CX.Cursor, namespace: str) -> List[CX.Cursor]:
    # if namespace is empty, return the cursor itself(global namespace)
    if not namespace:
        return [cursor]
    # find namespace
    namespace_split = [ns for ns in namespace.split('::') if ns]
    targets = []
    def walk(cursor: CX.Cursor, namespace: List[str]):
        if not namespace:
            targets.append(cursor)
            return
        for child in cursor.get_children():
            if child.kind == CX.CursorKind.NAMESPACE and child.spelling == namespace[0]:
                walk(child, namespace[1:])
    walk(cursor, namespace_split)
    return targets

def generate_header_prelude(header_writer: TextIO, extra_headers: List[str], target_name: str) -> None:
    header_writer.write('#pragma once\n')
    header_writer.write('/// Generated by codege.py, DO NOT MODIFY\n')
    content = f'''
#include <unordered_map>
#include <string_view>
#include <variant>

'''
    header_writer.write(content)
    for header in extra_headers:
        header_writer.write(f'#include <{header}>\n')
    header_writer.write(f'''
template<typename T>
struct {target_name};
''')

def generate_header(header_writer: TextIO, struct_info: StructInfo, target_name: str) -> None:
    types = set([t for t in [field.field_type for field in struct_info.fields]])
    variant = ', '.join([f'{t} Self::*' for t in types])
    header_writer.write(f'''
/// Generated for {struct_info.canonical_name}

template<>
struct {target_name}<{struct_info.canonical_name}> {{
    using Self = {struct_info.canonical_name};
    using FieldVariant = std::variant<{variant}>;
    static const std::unordered_map<std::string_view, FieldVariant> fields;

    static const std::unordered_map<std::string_view, std::unordered_map<std::string_view, std::string_view>> extras;
    Self get_default() const;
}};
''')
    header_writer.write('\n')

def generate_impl_prelude(writer: TextIO, header_path: str, target_name: str) -> str:
    # writer.write(f'#include "{header_path}"\n')
    # writer.write('/// Generated by codege.py, DO NOT MODIFY\n')
    # writer.write('usin')
    mangled_name = '__' + target_name.replace('<', '_').replace('>', '_').replace(' ', '_', 1).replace(':', '_')
    content = f'''
/// Generated by codege.py, DO NOT MODIFY

#include "{header_path}"

template<typename T>
using {mangled_name} = {target_name}<T>;
'''
    writer.write(content)
    return mangled_name

def generate_impl(impl_writer: TextIO, struct_info: StructInfo, mangled_name: str) -> None:
    content = f'''
/// Generated for {struct_info.canonical_name}
const std::unordered_map< std::string_view, {mangled_name}<{struct_info.canonical_name} >::FieldVariant> 
{mangled_name}<{struct_info.canonical_name} >::fields = {{
'''
    impl_writer.write(content)
    for field in struct_info.fields:
        content = f'    {{ "{field.name}", &{struct_info.canonical_name}::{field.name} }},\n'
        impl_writer.write(content)
    impl_writer.write('};\n\n')

    content = f'''
const std::unordered_map<std::string_view, std::unordered_map<std::string_view, std::string_view>>
{mangled_name}<{struct_info.canonical_name} >::extras = {{
'''
    impl_writer.write(content)
    for field in struct_info.fields:
        if field.extras:
            content = f'    {{ "{field.name}", {{'
            for k, v in field.extras.items():
                content += f'{{ "{k}", "{v}" }},'
            content += '}},\n'
            impl_writer.write(content)
    impl_writer.write('};\n\n')


    


@click.command()
@click.argument('source_header', type=click.Path(exists=True, readable=True))
@click.argument('out_header', type=click.Path())
@click.argument('out_impl', type=click.Path())
@click.option('--namespace', type=str, default='', help='The namespace to generate the code')
@click.option('--include-dir', type=str, multiple=True, help='The include directories to search for headers')
@click.option('--extra-headers', type=str, multiple=True, help='Extra headers to include in the generated header')
@click.option('--target-name', type=str, default='__reflect', help='The name of the generated')
def generate_code(source_header: str, out_header: str, out_impl: str, namespace: str, include_dir: List[str], extra_headers: List[str], target_name: str) -> None:
    """COMAMND: SOURCEFILE OUT_HEADER OUT_IMPL"""

    # Get system include paths
    system_paths = [p.decode() for p in ccsyspath.system_include_paths('c++')]
    include_dirs = system_paths + list(include_dir)

    source_header = os.path.abspath(source_header)

    # Parse the source header
    index = CX.Index.create()
    parse_args = ['-x', 'c++', '-std=c++17'] + [f'-I{d}' for d in include_dirs]
    tu = index.parse(source_header, args=parse_args)

    diags = list(tu.diagnostics)
    fataled = False
    for diag in diags:
        print(f'Diagnostics: severity={diag.severity}, location={diag.location}, msg={diag.spelling}')
        if diag.severity >= CX.Diagnostic.Error:
            fataled = True
    if fataled:
        sys.exit(1)
    
    # Find the namespace
    namespace_targets = find_namespace(tu.cursor, namespace)
    if not namespace_targets:
        print(f'Error: namespace {namespace} not found')
        sys.exit(1)
    
    struct_infos = []
    for ns_cursor in namespace_targets:
        for cursor in [struct for struct in ns_cursor.get_children() if struct.kind == CX.CursorKind.STRUCT_DECL]:
            struct_info = get_struct_fields(cursor)
            if struct_info:
                struct_infos.append(struct_info)
    
    if len(struct_infos) == 0:
        print('Warning: no struct found, plz check')
        return
    headers = [source_header]
    headers.extend(extra_headers)
    # Start generating code
    with open(out_header, 'w') as header_writer, open(out_impl, 'w') as impl_writer:
        header_abs_path = os.path.abspath(out_header)
        generate_header_prelude(header_writer, headers, target_name)
        mangled_name = generate_impl_prelude(impl_writer, header_abs_path, target_name)
        for struct_info in struct_infos:
            generate_header(header_writer, struct_info, target_name)
            generate_impl(impl_writer, struct_info, mangled_name)

    
if __name__ == '__main__':
    generate_code()